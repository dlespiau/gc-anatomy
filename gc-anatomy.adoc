= Anatomy of the Go compiler
Damien Lespiau <damien.lespiau@gmail.com>
v0.1
:toc:
:icons: font
:hide-uri-scheme:
:source-highlighter: coderay
:quick-uri: http://dlespiau.github.io/go-gc-anatomy/

This article is the results of notes taken while walking through `gc`, the
compiler distributed as part of the https://golang.org/[Go project].

== The basics

=== Quick history

- go rewrite
- link to video
- SSA

Talk about gccgo/llgo. 

=== Invoking the Go compiler

`go build` invokes separate compiler and linker binaries behind the scenes
as shown by the `-x` option:

[source%nowrap,shell]
----
$ go build -x
WORK=/tmp/go-build049312878
mkdir -p $WORK/_/home/damien/src/hello-world/_obj/
mkdir -p $WORK/_/home/damien/src/hello-world/_obj/exe/
cd /home/damien/src/hello-world
$GOROOT/pkg/tool/linux_amd64/compile -o $WORK/_/home/damien/src/hello-world.a -trimpath $WORK -p main -complete -buildid b41aca5027f01d4edf98e1676ee20bd7375510e3 -D _/home/damien/src/hello-world -I $WORK -pack ./main.go
cd .
$GOROOT/pkg/tool/linux_amd64/link -o $WORK/_/home/damien/src/hello-world/_obj/exe/a.out -L $WORK -extld=gcc -buildmode=exe -buildid=b41aca5027f01d4edf98e1676ee20bd7375510e3 $WORK/_/home/damien/src/hello-world.a
cp $WORK/_/home/damien/src/hello-world/_obj/exe/a.out hello-world
----

The Go compiler is really the `compile` tool. The `compile` tool can be
invoked on its own:

[source,shell]
----
$ go tool compile main.go
$ ls main*
main.go  main.o
----

=== Filesystem layout

While to the `go` binary is in `$GOROOT/bin`, tools are located in
`$GOROOT/pkg/tool/$GOOS_$GOARCH`. On Linux with an x86â€‘64 processor, the
compiler can be found in `$GOROOT/pkg/tool/linux_amd64`.

=== Compiler options

The compiler has quite a few options to play with. Most of them are to
support the integration with `go build`. Some, however, can help
understanding and debugging the compiler itself.

Consider the following Hello World program.

[source,go]
----
package main

func printHelloWorld() {
        println("Hello, World!")
}

func main() {
        printHelloWorld()
}
----

The `-m` option tells us about optimisation decisions the compiler has done.
In this instance `printHelloWorld` can be inlined.

[source,shell]
----
$ go tool compile -m main.go
main.go:3: can inline printHelloWorld
main.go:7: can inline main
main.go:8: inlining call to printHelloWorld
----

NOTE: Compiler options can be passed from `go build` as well with the `-gcflags`
parameter, eg. `go build -gcflags '-m'`.

When applicable, I'll indicate how to get relevant debugging information for
the topic discussed in the rest of this article.

=== Sources

== Escape Analysis

=== Inlining

https://en.wikipedia.org/wiki/Inline_expansion[Inlining] is quite an important
optimisation. Not only it removes some function call overhead but, more
importantly, it enables further function-wide optimisations at a later stage.

The inlining code is in @@src/cmd/compile/internal/gc/inl.go@@ with a nice
explanatory comment at the top of the file. A first pass in
@@src/cmd/compile/internal/gc/inl.go:caninl@@ decides which functions can be
inlined. A second pass, @@src/cmd/compile/internal/gc/inl.go:inlcalls@@, will
expand inlinable functions at their call sites.

@@src/cmd/compile/internal/gc/inl.go:ishairylist@@ and
@@src/cmd/compile/internal/gc/inl.go:ishairy@@  walk the function and decide if
it's too _hairy_ (ie. complex) to be inlined or not with a budget of 80 AST
nodes.

The Go compiler can inline across package boundaries.

The inliner only inlines leaf functions (with
https://github.com/golang/go/commit/77ccb16eb12f461eaea5fdf652a2e929dc154192[some exceptions^]).
https://github.com/golang/proposal/blob/master/design/19348-midstack-inlining.md[Mid-stack
inlining^] is in the pipeline.

The `-m` flag can be used to see the inliner in action:

[source,go]
----
include::inlining/inlined/inlined.go[]
----

[source,shell]
----
$ go tool compile -m inlined.go
include::inlining/inlined/inlined.output[]
----

The undocumented option `-m=2` gives more insights into the reasons the
compiler doesn't inline certain functions.

[source,go]
----
$ cat not-inlined.go
include::inlining/not-inlined/not-inlined.go[]
----

[source,shell]
----
$ go tool compile -m=2 not-inlined.go
include::inlining/not-inlined/not-inlined.output[]
----

=== Escape Analysis

TODO

=== SSA

TODO

== Interaction with the runtime

=== Growing stacks

== Chosen pieces

=== Go calling convention

=== Go assembler
